<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name= "description" content="A page about HTML">
<link rel="stylesheet" type="text/css" href="style_code.css"/>
<script src="./javaa.js"> </script>
<link href="https://fonts.googleapis.com/css?family=Meera+Inimai&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=VT323&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Patrick+Hand+SC&display=swap" rel="stylesheet">
<title>Corporate Coding Summary For Kids By Steffanie Padilla</title>


<!--BORDER FUNCTION START-->

<body onmouseover="firstFunction()" onmouseleave="secondFunction()">
<div id="b1" class="border"></div>

<!--BORDER FUNCTION END-->

<h6> WHAT <em>IS</em> CODE? <br> By: Paul Ford <br> â€” for kids <br>ğŸ”¥ğŸ‘©â€ğŸ’»ğŸ‘¨â€ğŸ’»ğŸ”¥</h6>

<h1><br>chapter 3 </br>
<br> WHY ARE PROGRAMMERS <br> SO INTENSE ABOUT LANGUAGES?
<br>ğŸ‘¹</br>
</h1>

<p> Many conferences are organized around specific programming languages or
specific communities (PyCon for Python programmers; the Strata conference
for big data; Oscon for open-source coders); these are ritual events for the
people in those communities. Attendees gather, talk, and post the videos on
YouTube. Language matters.</p>

<p> Programmers track the success of computer languages the way other people
track sports rankings, commenting on Web forums such as
<a href="https://www.reddit.com/" target="_blank"> Reddit</a> 
(where many languages get their own â€œsubreddit,â€ and reddit.com/r/programming
currently has 620,202 readers), or 
<a href="https://news.ycombinator.com/" target="_blank">Hacker News </a>
, run by the venture capital firm Y Combinator (a company named after a special
kind of function that operates on other functions), or Lambda the Ultimate 
(named after a series of papers written mostly in the 1970s about the 
influential programming language Schemeâ€”the more inside-baseball the name, 
the nerdier the subject matter). </p>

<p> There are hundreds of programming blogs. Many large corporations let their
engineers blog (a generous gift, given how many recruiters are hovering).
Discussions about programming go on everywhere, in public, at all times,
about hundreds of languages. There is a keen sense of whatâ€™s coming up and
whatâ€™s fading out. </p>

<p> Itâ€™s not simply fashion; oneâ€™s career as a programmer depends on
demonstrating capacity in one or more languages. So there are rankings,
frequently updated, rarely shocking. As of April 15, the worldâ€™s most-used
computer languages, according to the Tiobe index (which uses a variety of
indicators to generate a single ranking for the world of programming), are
Java, C, C++, Objective-C, and C#, followed by JavaScript, PHP, and Python.
The rankings are necessarily inexact; another list, by a consulting firm called
RedMonk, gives JavaScript the top spot, followed by Java. There are many
possible conclusions here, but the obvious one is that, all things being equal,
a very good Java programmer who performs well in interviews will have
more career options than a similar candidate using a more obscure language.
If you code, by the time a language breaks through to the top 10 or 20, youâ€™ve
heard of it, read blog posts about it, heard people lament how terrible or
wonderful or misguided it is, possibly watched a few video tutorials, or
played with it a little. Taking new languages out for a spin is a good thing for
a programmer to do. Often all you have to do is download some files and
write a couple lines of code, then decide if you want to go further. Most
languages are free to download and use. </p>

<p> Why do people construct and then give away free languages? Well, the
creation of a good computer language is the work of an apex programmer. To
have produced a successful language is acknowledged as a monumental
effort, akin to publishing a multivolume history of a war, or fighting in one.
The reward is glory.</p>

<p> Changing a language is like fighting that war all over again, and some
languages have at times been trapped in a liminal state between their old,
busted selves, and their new, promised version. Perl 5, released in the 
mid1990s, was a language uniquely suited to the World Wide Web, and it grew as
the Web grew; Perl 6 was supposed to be better in every way, and a redesign
began with grand pronouncements in 2000. But after 15 years of people
working continually and often for free on a project they consider in the
public interest, thereâ€™s still no official Perl 6. (Latest ETA: Christmas 2015.)
The Python language community, keenly aware of the Perl communityâ€™s
problems, decided to make necessary but difficult changes to the language as
part of the transition from Version 2 to Version 3. They would modernize,
clean up rough edgesâ€”but avoid grand reinventions. Development of
Python 3.0 started in 2006; the first working version came out in 2008; and
in 2015, the transition is ongoing. </p>
    
<p> Making a new language is hard. Making a popular language is much harder
still and requires the smile of fortune. And changing the way a popular
language works appears to be one of the most difficult things humans can do,
requiring years of coordination to make the standards align. Languages are
large, complex, dynamic expressions of human culture. </p>




<h1>(3.1) 
<br> THE BEAUTY OF THE STANDARD LIBRARY
<br> ğŸŒ ğŸŒ·ğŸŒ·ğŸŒ·ğŸŒ·ğŸŒ·ğŸŒ·ğŸŒ·ğŸŒ· ğŸŒ</br>
</h1> 


<p> The true measure of a language isnâ€™t how it uses semicolons; itâ€™s the standard
library of each language. A language is software for making software. The
standard library is a set of premade software that you can reuse and reapply.</p>

<p> Take Python, which is â€œbatteries included,â€ meaning that it comes with tons
of preexisting code, organized into â€œmodules,â€ that you can reuse. Its
standard library has functions that let you copy Web pages or replace words
in a document. </p>

<p> What does that mean, to process text? Well, you might have a string of text
(The Quick Brown Fox) and save it in a variable called my_string. So now
you can call standard methods on that string. You can say
my_string.lower(), and it will make all the words lowercase, producing
3.1 The Beauty of the Standard Library The Beauty of the Standard Library
â€œthe quick brown fox.â€ </p>

<p> Truly understanding a languageâ€™s standard library is one of the ways one
becomes proficient in that language. Typically you just visit Web pages or
read a book. </p>

<p> But the standard library is only the beginning. For many languagesâ€”and
Python is exemplaryâ€”thereâ€™s an enormous library of prewritten modules
available for nearly instantaneous download, using â€œpackage managerâ€
software. A module (or library, or package) is code that is intended to extend
a languageâ€™s capabilities. </p>

<p> Letâ€™s say you work for an advertising agency and need to process through
100,000 pictures and scale and sharpen them. </p>

<p> You type one command: sudo pip install Pillow, and the Pillow
module is downloaded, compiled automatically, and placed into the correct
directory for later reuse. You have to know, of course, that most modern
languages have modules for image processing; you also need to know that
Pillow is the most commonly used image-processing toolkit. Knowing how to
find that out is part of the job of coding. You might learn it by Googling. You
might ask a friend. You might get that information out of a book, or a website
like The Hitchhikerâ€™s Guide to Python. </p>

<p> A coder needs to be able to quickly examine and identify which giant,
complex library is the one thatâ€™s the most recently and actively updated and
the best match for his or her current needs. A coder needs to be a good
listener. </p>

<p> But what a payoff! Now that Pillow is installed, you have, at your typing
fingertips, dozens of routines and functions related to image processing that
you can use in your code: change colors, rotate by a number of degrees, scale,
convert GIF images to JPEGs, and so forth. Or if you need to do very complex
numerical analysis and statistics work, you can download NumPy, and
suddenly an enormous range of mathematical algorithms are available to
you, hundreds of years of science and research boiled down. Audio
processing, interacting with peculiar hardware, speaking to databasesâ€”
there are packages for all of these things. But you need to know how to find
them, what they are called. Code isnâ€™t just obscure commands in a file. It
requires you to have a map in your head, to know where the good libraries,
the best documentation, and the most helpful message boards are located. If
you donâ€™t know where those things are, you will spend all of your time
searching, instead of building cool new things. </p>


<h1>(3.2) <br> WHAT DO DIFFERENT LANGUAGES DO?
<br>ğŸ¤” ğŸ¤” ğŸ¤” ğŸ¤” ğŸ¤” ğŸ¤” ğŸ¤” ğŸ¤” ğŸ¤”</br>
</h1>

<p> If all computer languages do the same thing (make the computer do what
you want), then why does it matter which one you choose? For the same
reason that you wouldnâ€™t take a bicycle to pick up a fridge or get a physical
from an oncological neurosurgeon. Some tools are better for certain jobs. </p>

<p> Itâ€™s possible for a C programmer and a Java programmer to read each otherâ€™s
code, but itâ€™s harder to make C code and Java code work together. C and Java
represent the world in different ways, structure data in different ways, and
address the components of the computer in different ways. There are true
benefits to everyone on a team using the same language. Theyâ€™re all thinking
the same way about how to instruct the computer to process data.</p>

<p> Itâ€™s not necessary for every team across a big organization to use the same
language. In fact, itâ€™s often counterproductive. Large organizations have lots
of needs and use many languages and services to meet them. For example,
Etsy is built atop PHPâ€”but its product-search service uses Java libraries,
because the solutions for search available in Java are great. </p>

<p> Some programming languages, such as C, will do their best to do exactly as
you ask, even if that means crashing your computer. Others, like OCaml and
Haskell, are very constrained and ask a programmer to hew to a narrow form,
trying to steer you away from anything stupid.</p> 

<p>Some languages have cute logos, like the Go gopher. <br> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ click on logos and watch them get big and change to black & white! </p>


<!--GOPHER IMAGE-->
<div><img id= "image1" class="gopher" src="media/1.jpg"
onclick="thirdFunction()"></div>


<p>Thereâ€™s Scratch, a teaching language for kids. It doesnâ€™t use text much at all
but allows liâ€™l coders to move icons around on screen and assemble programs
like Legos. Its logo is a smiling cat on two legs.</p>


<!--CAT IMAGE-->
<div><img id= "image2" class="cat" src= "media/2.jpg"
onclick="fourthFunction()"></div>


<p> And then thereâ€™s Lisp, which didnâ€™t come with a logo when it was first
proposed in the 1950s but now has a community-created five-eyed alien
holding a flag with its proboscis. Lisp is a classic language. There are some
languages that just have authority, eleganceâ€”canonical computer
languages </p>


<!--MONSTER IMAGE-->
<div><img id= "image3" class="monster" src= "media/3.jpg"
onclick="fifthFunction()"></div>


<p> And one of these is C. Most of the popular languages look a lot like it. Câ€™s de
facto logo is, well, the letter C. C is called C because it came after another
language. That language was called B. </p>



<h1>(3.3) <br> THE IMPORTANCE OF C 
<br>ğŸŠğŸŠğŸŠğŸŠğŸŠğŸŠğŸŠğŸŠğŸŠğŸŠğŸŠğŸŠ</br>
</h1>


<p> C is as big a deal as you can get in computing. Created by Dennis Ritchie
starting in the late 1960s at Bell Labs, itâ€™s the principal development
language of the UNIX operating system. Unix (lowercased now, to refer to the
idea of Unix instead of the branded version) is a simple operating systemâ€”
basically itâ€™s a kernel that manages memory and runs software, a large
collection of very small utility programs, and a â€œshellâ€ that helps you knit
programs into â€œshell scripts.â€ If you couldnâ€™t do what you needed with shell
scripts, you might write a new utility in C and add it to the utility library.
This was a nice and practical way of working, and it coincided with the rise
of various kinds of networks that today we refer to collectively as the
Internet. So Unix spread from Bell Labs to academia, to large industrial
systems, and eventually leached into the water supply of computing until it
was everywhere. And everywhere that Unix went, C was sure to go. </p>

<p> C is a simple language, simple like a shotgun that can blow off your foot. It
allows you to manage every last part of a computerâ€”the memory, files, a
hard driveâ€”which is great if youâ€™re meticulous and dangerous if youâ€™re
sloppy. Software made in C is known for being fast. When you compile C, it
doesnâ€™t simply become a bunch of machine language in one go; there are
many steps to making it really,ridiculously fast. These are called
optimizations, and they are to programming what loopholes are to
taxes. Think of C as sort of a plainspoken grandfather who grew up
trapping beavers and served in several wars but can still do 50 pullups. </p>


<div><img id= "image4" src= "media/4.jpg"></div>

<p> Câ€™s legendary, lucid manual and specification, The C Programming
Language, written by Ritchie and Brian Kernighan (known by its 
nickname,K&R), is a quick and simple readâ€”physically light in 
comparison with modern, heavy-stock guides to programming on bookstore 
shelves. This recommended text was published in 1978, when personal 
computing barely existed, back when a computer was a large piece of 
industrial equipment used to control a refrigeration system or calculate 
actuarial tables. It was in K&R that â€œHello, world!â€ became the canonical 
example program for any language. By convention, almost every introduction 
to any programming language since then starts with a variation 
on â€œHello, world!â€ </p>

<p> Here is the ur-text of computational self-introduction: </p>

<img id= "image5" src= "media/5.jpg">

<p> Which will, when compiled and run, print â€œHello, world!â€ to the screen. Letâ€™s
write a program where you give it a number x and it prints out all the squares
of the numbers from 1 to xâ€”just the sort of practical, useful program that
always appears in programming tutorials to address the needs of people who
urgently require a list of squares. </p>

<img id="image6" src= "media/6.jpg">

<p> To compile this program on a Macintosh, I saved it as squares.c and
opened up Terminal.app and typed: </p>

<img id= "image7" src= "media/7.jpg">

<p> And it produced: </p>

<p>
<ul class="list1">
<li>1</li>
<li>4</li>
<li>9</li>
<li>16</li>
<li>25</li>
<li>36</li>
<li>49</li>
<li>64</li>
<li>81</li>
<li>100</li>
</ul>
</p>

<p> That runs the GNU C Compiler and produces a default file called a.out,
which I ran on the command line, to get my squared numbers, and
bully for me. If I wanted to change the code, I would run the commands, and
the program would update accordingly. </p>

<p> This isnâ€™t great code by any stretch. You just need to squint a little to
see that there are small, repeatable units that fit together in certain ways.
Thereâ€™s a function called squares. Thatâ€™s the important part. You feed it a
number, an integer. Then it counts from 1 to that integer and with each count
it prints the square of that number. Then it prints a new line. Done. </p>

<p> The Linux kernel is written in C. The software that connects your printer to
your computer could be in C. The Web servers that serve up your Web pages
are often written in C. Itâ€™s also a good language for writing other languagesâ€”
Python, PHP, and Perl are written in C, as are many others. C is a language
you use for building systems; it has the same role in computing that Latin
did among Renaissance academics. You wonâ€™t often meet a serious
practitioner of the digital arts who doesnâ€™t have at least a passing familiarity.
The more serious scholars are pretty fluent. </p>

<p> But remember that list of popular languages? C++? Objective-C? C#? Java?
What many people code daily is not actually C, but one of the many Vulgates.
Advocates of these languages make various arguments in their favor; they
are better for large groups, for â€œprogramming in the large.â€ These languages,
they say, organize code into libraries that are shareable, reusable, and less
likely to cause pain and suffering. These are object-oriented adaptations of C.</p>


<h1>(3.4) <br> THE CORPORATE OBJECT REVOLUTION
<br>ğŸ’¸  ğŸ‘©â€ğŸ’¼ğŸ‘”ğŸ“ ğŸ“‚ğŸ“ŠğŸ—„ğŸ“ ğŸ“‚ğŸ“ŠğŸ‘¨â€ğŸ’¼  ğŸ’¸</br>
</h1>


<p> If youâ€™re going to understand how code works in a corporate environment,
you need to understand what object-oriented programming is. </p>

<p> There are many definitions. Iâ€™ll wade in and provide my own and face the
consequences. Object-oriented programming is, at its essence, a filing
system for code. As anyone whoâ€™s ever shared a networked folderâ€”or
organized a physical filing cabinetâ€”knows, without a good shared filing
system your office will implode. C, people said in the 1980s and â€™90s, is a
great language! An excellent language! But it doesnâ€™t really let you organize
things. You end up with all these functions. Itâ€™s a mess. I mean, we have this
data structure for our customers (name, address, and so forth), and we have
all these functions for manipulating that data (update_address,
send_bill, delete_account), but the thing is, those functions arenâ€™t
related to the data except by the naming convention. C doesnâ€™t have a
consistent way to name things. Which means itâ€™s hard to find them later.
Object-oriented programming gave programmers a great way to name things
â€”a means of building up a library. I could call (run) update_address on a
picture of a dog or an Internet address. That approach is sloppy and
dangerous and leads to bugs (our forebears reasoned, and not without
precedent), and it makes it hard to program with big teams and keep track of
everything. </p>

<p> So what if, whaaaat if, we made a little
box called Customer (call it a â€œclass,â€ as
in the taxonomical sense, like a
Customer is a subclass of the species
human, which is a subclass of mammal,
etc.), and we put the data and methods
relating to customers into that box. (And
by box, itâ€™s literally just â€œpublic class
Customer {}â€ and anything inside the
{} relates to that particular class.) </p>    

<p> I mean, you wouldnâ€™t even need to look
inside the box. Youâ€™d just download a
large set of classes, all nested inside one
another, study the available, public
methods and the expected data, and start
programming. Hey, youâ€™d say, letâ€™s put
some data into our object, take some data
out. Every time we have a new customer
we make a new instance of our class.
Code can be a black box, with tentacles
and wires sticking out, and you donâ€™t
need toâ€”donâ€™t want toâ€”look inside the
box. You can just put a couple of boxes
next to each other, touch their tentacles 
together, and watch their eldritch mating. </p>

<p> This works out very well, in theory.</p>

<p> The archetypal object-oriented programming language is Smalltalk, created
by a coterie of geniuses at Xerox PARC during that institutionâ€™s most glorious
of glory days. After years of gestation, Smalltalk was born in 1972, the same
year as C, and gelled around 1980. It was inspired by many of the big ideas in
computer science, but also by Platonism, by cell biology, and by a
predecessor language called Simula, the first object-oriented language,
which per its name was designed to â€¦ simulate things. While C was created
within the New Jersey research facilities (Bell Labs) of an industrial monolith
(AT&T) to solve problems at hand, Smalltalk was built at the far-off California
outpost of a different industrial monolith, Xerox, to solve the problems of the
distant future. Thus Smalltalk represents the world differently than C. </p>


<p> Smalltalk has a funny name and a friendly attitude, but its specification ran
to 700 pages. It was a big system. C gave you an abstraction over the entire
computer, helping you manage memory and processes inside the machine.
Smalltalk gave you an abstraction over all of reality, so you could start
dividing the world into classes and methods and the like. Where C tried to
make it easier to do computer things, Smalltalk tried to make it easier to do
human things. </p>

<p> This isnâ€™t better or worse. Itâ€™s just different. Here is some Smalltalk code: </p>

<p> Transcript show: 'Hello, world!'.</p>

<p>It prints that short sentence in the Transcript Window on the userâ€™s screen.
The Transcript is an objectâ€”and here itâ€™s receiving a message (show:) with
an argumentâ€”i.e., inputâ€”â€œHello,â€ etc. You type that in, select it with your
mouse (even in the early 1980s), and tell the computer to execute it. It
compiles just that bit of code and adds it to the rest of the running system. 
It looks like this:</p>

<p>Tons of windows all talking to each other. Each window is, well, an object. 
And instead ofprogramming it and compiling the program, then running it, you 
just dive right into this living,breathing, window-full environment, and 
start making new objects that send messages to otherobjects. If you save 
where you are, and come back five years later, well, everything will look 
exactlythe same.</p>


<p>The thing is, all those boxes can be manipulated. Theyâ€™re all objects. Itâ€™s
almost too powerful: The boundaries that are clear in most languagesâ€”
between data and code, between files and executables, between the
operating system and applications, between closed and open softwareâ€”all of
those borders are fuzzed by design. Smalltalk is a vision of the computer as
its own, native medium. The whole system can be modified, by anyone. The
dominant version is called Squeak (logo: cute mouse), and a modernized
version is called Pharo (logo: lighthouse). Both are free and easy to
download.</p>


<p>As a middling programmer I find the Smalltalk environment fascinating, but
it never pulls me all the way through the looking glass. One day, Iâ€™ve
promised myself, Iâ€™ll read (or skim with intent) the huge Smalltalk
specification from the 1980sâ€”a seminal text and a grand attempt to organize
reality along computer principles. The problem is that Smalltalk requires one
to adopt not just a method of working but also a philosophy of the world,
where everything is organized in a hierarchy of classes. I love to play with it,
but I typically stumble back to more familiar approaches. Being an advocate
for Smalltalk is a little like being very into Slovenian cinema or free jazz.
Some of its advocates are particularly brilliant people. Iâ€™m not one of them.</p>


<p>Smalltalkâ€™s history is often described as slightly tragic, because many of its
best ideas never permeated the culture of code. But itâ€™s still around, still has
users, and anyone can use Squeak or Pharo. Alsoâ€”</p>

<p>
<ol class="list2">
<li>Java is an object-oriented language, influenced by C++, that runs on a
virtual machine (just like Smalltalk).</li>
<li>Objective-C, per its name, jammed C and Smalltalk together with no
apologies.</li>
<li>C# (pronounced â€œC sharpâ€) is based on C and influenced by Java, but
it was created by Microsoft for use in its .NET framework.</li>
<li>C++ is an object-oriented version of C, although its roots are more in
Simula.</li>
</ol>
<p>

<p>The number of digital things conceived in 1972 that are still under regular
discussion is quite small. (It was the year of The Godfather and Al Greenâ€™s
Letâ€™s Stay Together.) The world corrupts the pure vision of great ideas. I
pronounce Smalltalk a raging, wild, global success.</p>



<h1>(3.5) <br>LOOK HOW <span class="largetext">BIG</span> AND WEIRD THINGS<br> GET WITH JUST PYTHON

    <div>ğŸ  ğŸŠğŸ¢ğŸ¦ğŸ‰ğŸ¦–ğŸ²ğŸŠğŸ¢ğŸ¦ğŸ‰ğŸ¦–  ğŸ</div></h1>


<p> Python is a very interesting language and quite popular, too. 
Itâ€™s objectoriented but not rigid. And itâ€™s widely understood to 
be easier than C for programmers to use, because it provides more 
abstractions for programmers to reuse. It hides much of the weirdness of 
the computer and many details of how computation is performed. Python is 
usually slower than C; this is the price you pay for all those sweet 
levels of abstraction. In the vast majority of cases this difference in 
speed truly doesnâ€™t matter, regardless of how much people protest. 
Itâ€™s only of consequence when youâ€™ve built up a system in Python and a 
part of it runs millions or billions of times, slowing down the
computerâ€”and thus requiring more resources to get its work done.</p>


<p> What then? Does this mean you need to throw away all your Python and start
over in some other language? Probably not. Python has a deserved
reputation as a â€œglue language,â€ meaning you can take code from other,
lower-level languages such as C, C++, and Fortran 77 (yes, as in the year 1977),
code that is close to the machine and known to be sound, and write â€œwrapper
functions.â€ That is, you can embed the older, faster code in the newer,
slower, but easier-to-use system.</p>


<p> A big part of this process is in wrapping up the old code in nice, wellorganized Python functions. In many ways the idiom of a language is not just
how it looks but also how it feels. Some languages emphasize brevity. Some
support long, complex functions, while others encourage you to break up
functionality into small pieces. Style and usage matter; sometimes
programmers recommend Strunk & Whiteâ€™s The Elements of Styleâ€”thatâ€™s
right, the one about the English language. Its focus on efficient usage
resonates with programmers. The idiom of a language is part of its
communal identity.</p>

<p> Python is not the glue for everything, though. Itâ€™s hard to connect to Java but
fits C hand to glove. Thereâ€™s a version of Python designed to run inside of
Java and use Java code. Thatâ€™s called Jython. If you want a version that
works with Microsoftâ€™s .NET, you can go with IronPython.</p>


<p> But thereâ€™s another way to interpret all this activity around Python: People
love it and want it to work everywhere and do everything. Theyâ€™ve spent tens
of thousands of hours making that possible and then given the fruit of their
labor away. Thatâ€™s a powerful indicator. A huge amount of effort has gone
into making Python practical as well as pleasurable to use. There are lots of
conferences, frequent code updates, and vibrant mailing lists. You pick a
language not just on its technical merits, or its speediness, or the job
opportunities it may present, but also on its culture.</p>

<p>Python people, generally, are pretty cool.</p>
<br>

<hr class="line">

<header>
<h2>READING RESPONSE TIME! 
<div>ğŸŒˆâœ¨  ğŸ™‹â€â™€ï¸ğŸ™‹â€â™‚ï¸ğŸ™‹  âœ¨ğŸŒˆ</div>
</h2></header>

<br>
<h5 class="blue">So why <em>are</em> programmers so intense about languages?  3.0 </h2>

<p>This section made me realize that coding is a big thing with a big community. 
Programming is such a popular skill to have that recruiters are regularly searching for new skilled workers. 
Due to high demand, it is now better, if not necessary, to know 
multiple programs and to know them really well. 
To answer the question, I think programmers are so 
intense (passionate?) about languages because maybe they have to
fight for the ones they believe is best (and by fight I mean get really good at and attend conferences). 
Also, it seems that programmers are always looking for new ways to improve a language 
and so they obsess over it. Maybe the word intensity, in this case, is synonymous for passionate. 
Say they are passionate about programming, this passion might also come from an awe of 
the software on how powerful it is and thus making them feel powerful in return.</p>

<h5 class="green"> So what <em>is</em> the beauty of the standard library? 3.1 </h5>

<p>
This section made me think about Photoshop presets since standard libraries (also known as,
pacakges or modules) are a form of presets used to automate an action. To answer the 
question, what makes standard libraries beautiful is that they can apply things to many other things
simultaneously. A standard library works as an extension of words (syntax) to an existing 
language. The most important thing to know is how to find these packages so more 
time is spent building rather than searching.<p>

<h5 class="red">So what <em>can</em> different coding languages do? 3.2</h5>

<p>After reading this section I Google, â€œHow many languages are there in programming?â€ 
The answer was more than 700. This was surprising to learn and caused me wonder, 
Why do we need so many languages? The analogy of programs being specific 
tools for specific purposes made sense,
but needing 700+ tools is difficult to understand.</p>

<h5 class="yellow"> So why <em>is</em> C important? 3.3</h5>

<p>This section made me think about just how intricate computers really are and how 
dependent they are of us to make them do things (or anything 
for that matter). Before reading this article, I had not given much thought as to how 
much learning is required to program and the amount of time it takes. I gained a better 
appreciation for computer programmers, web developers and engineers. </p>

<h5 class="magenta">So what <em>is</em> the corporate revolution? 3.4</h5>
<p>The corporate revolution is this thing called â€œObjectâ€-oriented programming and 
what it does essentially is organize files (data).</p>

<h5 class="gray">So <em>how</em> big and weird do things get with just Python? 3.5</h5>

<p>Things get really weird and really big with Python because Python is like 
this monolith monster that can transform into other versions like Jython and 
IronPython to run other code like Java and .NET that regular Python canâ€™t read. 
Python can also use very old code (low-level languages) and wrap them up to consume.</p>

<h6>Thanks For Reading!</h6>

</body>
</html>